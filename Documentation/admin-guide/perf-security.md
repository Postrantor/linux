---
tip: translate by baidu@2024-01-30 21:36:30
---
---
title: Perf events and tool security
---

# Overview


Usage of Performance Counters for Linux (perf_events)[^1] ,[^2] ,[^3] can impose a considerable risk of leaking sensitive data accessed by monitored processes. The data leakage is possible both in scenarios of direct usage of perf_events system call API[^4] and over data files generated by Perf tool user mode utility (Perf)[^5] ,[^6] . The risk depends on the nature of data that perf_events performance monitoring units (PMU)[^7] and Perf collect and expose for performance analysis. Collected system and performance data may be split into several categories:

> 使用Linux性能计数器（perf_events）[^1]、[^2]、[^3]可能会造成被监视进程访问的敏感数据泄露的相当大的风险。在直接使用perf_events系统调用API[^4]的情况下，以及在perf工具用户模式实用程序（perf）[^5]、[^6]生成的数据文件上，都可能发生数据泄露。风险取决于性能监控单元（PMU）[^7]和perf为进行性能分析而收集和公开的数据的性质。收集的系统和性能数据可分为以下几类：


1.  System hardware and software configuration data, for example: a CPU model and its cache configuration, an amount of available memory and its topology, used kernel and Perf versions, performance monitoring setup including experiment time, events configuration, Perf command line parameters, etc.

> 1.系统硬件和软件配置数据，例如：CPU型号及其缓存配置、可用内存量及其拓扑结构、使用的内核和Perf版本、性能监控设置，包括实验时间、事件配置、Perf命令行参数等。

2.  User and kernel module paths and their load addresses with sizes, process and thread names with their PIDs and TIDs, timestamps for captured hardware and software events.

> 2.用户和内核模块路径及其负载地址及其大小、进程和线程名称及其PID和TID、捕获的硬件和软件事件的时间戳。

3.  Content of kernel software counters (e.g., for context switches, page faults, CPU migrations), architectural hardware performance counters (PMC)[^8] and machine specific registers (MSR)[^9] that provide execution metrics for various monitored parts of the system (e.g., memory controller (IMC), interconnect (QPI/UPI) or peripheral (PCIe) uncore counters) without direct attribution to any execution context state.

> 3.内核软件计数器（例如，用于上下文切换、页面故障、CPU迁移）、体系结构硬件性能计数器（PMC）[^8]和机器特定寄存器（MSR）[^9]的内容，这些计数器为系统的各个受监控部分（例如，内存控制器（IMC），互连（QPI/UPI）或外围（PCIe）非核心计数器），而不直接归因于任何执行上下文状态。

4.  Content of architectural execution context registers (e.g., RIP, RSP, RBP on x86_64), process user and kernel space memory addresses and data, content of various architectural MSRs that capture data from this category.

> 4.体系结构执行上下文寄存器的内容（例如，x86_64上的RIP、RSP、RBP）、进程用户和内核空间内存地址和数据、捕获此类数据的各种体系结构MSR的内容。


Data that belong to the fourth category can potentially contain sensitive process data. If PMUs in some monitoring modes capture values of execution context registers or data from process memory then access to such monitoring modes requires to be ordered and secured properly. So, perf_events performance monitoring and observability operations are the subject for security access control management[^10] .

> 属于第四类的数据可能包含敏感的过程数据。如果在某些监控模式中的PMU捕获执行上下文寄存器的值或来自进程存储器的数据，则需要对这种监控模式的访问进行适当的排序和保护。因此，性能事件性能监视和可观察性操作是安全访问控制管理的主题[^10]。

# perf_events access control


To perform security checks, the Linux implementation splits processes into two categories[^11] : a) privileged processes (whose effective user ID is 0, referred to as superuser or root), and b) unprivileged processes (whose effective UID is nonzero). Privileged processes bypass all kernel security permission checks so perf_events performance monitoring is fully available to privileged processes without access, scope and resource restrictions.

> 为了执行安全检查，Linux实现将进程分为两类[^11]：a）特权进程（其有效用户ID为0，称为超级用户或root），以及b）非特权进程（有效UID为非零）。特权进程绕过所有内核安全权限检查，因此性能事件性能监视完全可用于特权进程，而不受访问、范围和资源限制。


Unprivileged processes are subject to a full security permission check based on the process\'s credentials[^12] (usually: effective UID, effective GID, and supplementary group list).

> 根据进程的凭据[^12]（通常为：有效UID、有效GID和补充组列表），对非特权进程进行完整的安全权限检查。


Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities[^13] , which can be independently enabled and disabled on per-thread basis for processes and files of unprivileged users.

> Linux将传统上与超级用户相关的权限划分为不同的单元，称为功能[^13]，可以在每个线程的基础上独立启用和禁用非特权用户的进程和文件。


Unprivileged processes with enabled CAP_PERFMON capability are treated as privileged processes with respect to perf_events performance monitoring and observability operations, thus, bypass *scope* permissions checks in the kernel. CAP_PERFMON implements the principle of least privilege[^14] (POSIX 1003.1e: 2.2.2.39) for performance monitoring and observability operations in the kernel and provides a secure approach to performance monitoring and observability in the system.

> 启用CAP_PERFMON功能的非特权进程在性能事件性能监视和可观察性操作方面被视为特权进程，因此，可以绕过内核中的*scope*权限检查。CAP_PERFMON实现了内核中性能监视和可观测性操作的最小特权[^14]原则（POSIX 1003.1e:2.2.2.39），并为系统中的性能监视和可观察性提供了一种安全的方法。


For backward compatibility reasons the access to perf_events monitoring and observability operations is also open for CAP_SYS_ADMIN privileged processes but CAP_SYS_ADMIN usage for secure monitoring and observability use cases is discouraged with respect to the CAP_PERFMON capability. If system audit records[^15] for a process using perf_events system call API contain denial records of acquiring both CAP_PERFMON and CAP_SYS_ADMIN capabilities then providing the process with CAP_PERFMON capability singly is recommended as the preferred secure approach to resolve double access denial logging related to usage of performance monitoring and observability.

> 出于向后兼容性的原因，对性能事件监视和可观察性操作的访问也对CAP_SYS_ADMIN特权进程开放，但对于CAP_PERFMON功能，不鼓励将CAP_SYS-ADMIN用于安全监视和可观测性用例。如果使用perf_events系统调用API的进程的系统审核记录[^15]包含获取CAP_PERFMON和CAP_SYS_ADMIN功能的拒绝记录，则建议将单独为进程提供CAP_PERFM功能作为解决与性能监视和可观察性的使用相关的双重访问拒绝日志记录的首选安全方法。


Prior Linux v5.9 unprivileged processes using perf_events system call are also subject for PTRACE_MODE_READ_REALCREDS ptrace access mode check [^16] , whose outcome determines whether monitoring is permitted. So unprivileged processes provided with CAP_SYS_PTRACE capability are effectively permitted to pass the check. Starting from Linux v5.9 CAP_SYS_PTRACE capability is not required and CAP_PERFMON is enough to be provided for processes to make performance monitoring and observability operations.

> 使用perf_events系统调用的先前Linux v5.9非特权进程也要接受PTRACE_MODE_READ_REALCREDS PTRACE访问模式检查[^16]，其结果决定是否允许监视。因此，具有CAP_SYS_PTRACE功能的非特权进程被有效地允许通过检查。从Linux v5.9开始，不需要CAP_SYS_PTRACE功能，并且为进程提供CAP_PERFMON就足以进行性能监视和可观测性操作。


Other capabilities being granted to unprivileged processes can effectively enable capturing of additional data required for later performance analysis of monitored processes or a system. For example, CAP_SYSLOG capability permits reading kernel space memory addresses from /proc/kallsyms file.

> 授予非特权进程的其他功能可以有效地捕获被监控进程或系统的后续性能分析所需的额外数据。例如，CAP_SYSLOG功能允许从/proc/kallsyms文件读取内核空间内存地址。

# Privileged Perf users groups


Mechanisms of capabilities, privileged capability-dumb files[^17], file system ACLs[^18] and sudo[^19] utility can be used to create dedicated groups of privileged Perf users who are permitted to execute performance monitoring and observability without limits. The following steps can be taken to create such groups of privileged Perf users.

> 功能机制、特权功能哑文件[^17]、文件系统ACL[^18]和sudo[^19]实用程序可用于创建特权Perf用户的专用组，这些用户被允许无限制地执行性能监视和可观测性。可以采取以下步骤来创建这样的特权Perf用户组。


1.  Create perf_users group of privileged Perf users, assign perf_users group to Perf tool executable and limit access to the executable for other users in the system who are not in the perf_users group:

> 1.创建具有特权的perf用户的perf_users组，将perf_uusers组分配给perf工具可执行文件，并限制系统中不在perf_user组中的其他用户访问该可执行文件：

```{=html}
<!-- -->
```
    # groupadd perf_users
    # ls -alhF
    -rwxr-xr-x  2 root root  11M Oct 19 15:12 perf
    # chgrp perf_users perf
    # ls -alhF
    -rwxr-xr-x  2 root perf_users  11M Oct 19 15:12 perf
    # chmod o-rwx perf
    # ls -alhF
    -rwxr-x---  2 root perf_users  11M Oct 19 15:12 perf


2.  Assign the required capabilities to the Perf tool executable file and enable members of perf_users group with monitoring and observability privileges[^20] :

> 2.将所需的功能分配给Perf工具可执行文件，并启用具有监视和可观察性权限的Perf_users组成员[^20]：

```{=html}
<!-- -->
```
    # setcap "cap_perfmon,cap_sys_ptrace,cap_syslog=ep" perf
    # setcap -v "cap_perfmon,cap_sys_ptrace,cap_syslog=ep" perf
    perf: OK
    # getcap perf
    perf = cap_sys_ptrace,cap_syslog,cap_perfmon+ep


If the libcap[^21] installed doesn\'t yet support \"cap_perfmon\", use \"38\" instead, i.e.:

> 如果安装的libcap[^21]还不支持“cap_perfmon\”，请使用“38\”，即：

    # setcap "38,cap_ipc_lock,cap_sys_ptrace,cap_syslog=ep" perf


Note that you may need to have \'cap_ipc_lock\' in the mix for tools such as \'perf top\', alternatively use \'perf top -m N\', to reduce the memory that it uses for the perf ring buffer, see the memory allocation section below.

> 请注意，对于“perf-top”等工具，您可能需要在组合中使用“cap_ipc_lock”，或者使用“perf-top-m N\”，以减少用于性能缓冲区的内存，请参阅下面的内存分配部分。


Using a libcap without support for CAP_PERFMON will make cap_get_flag(caps, 38, CAP_EFFECTIVE, &val) fail, which will lead the default event to be \'cycles:u\', so as a workaround explicitly ask for the \'cycles\' event, i.e.:

> 在不支持CAP_PERFMON的情况下使用libcap将使CAP_get_flag（caps，38，CAP_EFFECTIVE，&val）失败，这将导致默认事件为“cycles:u\”，因此解决方法明确要求“cycles\”事件，即：

    # perf top -e cycles

To get kernel and user samples with a perf binary with just CAP_PERFMON.


As a result, members of perf_users group are capable of conducting performance monitoring and observability by using functionality of the configured Perf tool executable that, when executes, passes perf_events subsystem scope checks.

> 因此，perf_users组的成员能够通过使用配置的perf工具可执行文件的功能进行性能监视和可观察性，该可执行文件在执行时通过perf_events子系统范围检查。


In case Perf tool executable can\'t be assigned required capabilities (e.g. file system is mounted with nosuid option or extended attributes are not supported by the file system) then creation of the capabilities privileged environment, naturally shell, is possible. The shell provides inherent processes with CAP_PERFMON and other required capabilities so that performance monitoring and observability operations are available in the environment without limits. Access to the environment can be open via sudo utility for members of perf_users group only. In order to create such environment:

> 如果无法为Perf工具可执行文件分配所需的功能（例如，文件系统安装了nosuid选项或文件系统不支持扩展属性），则可以创建功能特权环境，当然是shell。shell为固有进程提供CAP_PERFMON和其他所需的功能，以便在环境中无限制地进行性能监视和可观测性操作。只能通过sudo实用程序为perf_users组的成员打开对环境的访问。为了创造这样的环境：


1.  Create shell script that uses capsh utility[^22] to assign CAP_PERFMON and other required capabilities into ambient capability set of the shell process, lock the process security bits after enabling SECBIT_NO_SETUID_FIXUP, SECBIT_NOROOT and SECBIT_NO_CAP_AMBIENT_RAISE bits and then change the process identity to sudo caller of the script who should essentially be a member of perf_users group:

> 1.创建shell脚本，该脚本使用capsh实用程序[^22]将CAP_PERFMON和其他所需的功能分配到shell进程的环境能力集中，在启用SECBIT_NO_SETUID_FIXUP、SECBIT_NOROOT和SECBIT_NO_CAP_ambient_RAISE位后锁定进程安全位，然后将进程标识更改为脚本的sudo调用者，该调用者本质上应该是perf_users组的成员：

```{=html}
<!-- -->
```
    # ls -alh /usr/local/bin/perf.shell
    -rwxr-xr-x. 1 root root 83 Oct 13 23:57 /usr/local/bin/perf.shell
    # cat /usr/local/bin/perf.shell
    exec /usr/sbin/capsh --iab=^cap_perfmon --secbits=239 --user=$SUDO_USER -- -l


2.  Extend sudo policy at /etc/sudoers file with a rule for perf_users group:

> 2.在/etc/sudoers文件中使用perf_users组的规则扩展sudo策略：

```{=html}
<!-- -->
```
    # grep perf_users /etc/sudoers
    %perf_users    ALL=/usr/local/bin/perf.shell


3.  Check that members of perf_users group have access to the privileged shell and have CAP_PERFMON and other required capabilities enabled in permitted, effective and ambient capability sets of an inherent process:

> 3.检查perf_users组的成员是否有权访问特权shell，并在固有进程的允许、有效和环境功能集中启用CAP_PERFMON和其他所需功能：

```{=html}
<!-- -->
```
    $ id
    uid=1003(capsh_test) gid=1004(capsh_test) groups=1004(capsh_test),1000(perf_users) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
    $ sudo perf.shell
    [sudo] password for capsh_test:
    $ grep Cap /proc/self/status
    CapInh:        0000004000000000
    CapPrm:        0000004000000000
    CapEff:        0000004000000000
    CapBnd:        000000ffffffffff
    CapAmb:        0000004000000000
    $ capsh --decode=0000004000000000
    0x0000004000000000=cap_perfmon


As a result, members of perf_users group have access to the privileged environment where they can use tools employing performance monitoring APIs governed by CAP_PERFMON Linux capability.

> 因此，perf_users组的成员可以访问特权环境，在那里他们可以使用使用由CAP_PERFMON Linux功能管理的性能监视API的工具。


This specific access control management is only available to superuser or root running processes with CAP_SETPCAP, CAP_SETFCAP[^23] capabilities.

> 此特定的访问控制管理仅适用于具有CAP_SETPCAP、CAP_SETFCAP[^23]功能的超级用户或根运行进程。

# Unprivileged users


perf_events *scope* and *access* control for unprivileged processes is governed by perf_event_paranoid[^24] setting:

> 无特权进程的perf_events*scope*和*access*控制由perf_event_paranoid[^24]设置控制：

-1:


:   Impose no *scope* and *access* restrictions on using perf_events performance monitoring. Per-user per-cpu perf_event_mlock_kb[^25] locking limit is ignored when allocating memory buffers for storing performance data. This is the least secure mode since allowed monitored *scope* is maximized and no perf_events specific limits are imposed on *resources* allocated for performance monitoring.

> ：对使用perf_events性能监视不施加*scope*和*access*限制。为存储性能数据分配内存缓冲区时，将忽略每个用户每个cpu的perf_event_mlock_kb[^25]锁定限制。这是最不安全的模式，因为允许监视的*范围*被最大化，并且没有对分配用于性能监视的*资源*施加性能事件特定的限制。

\>=0:


:   *scope* includes per-process and system wide performance monitoring but excludes raw tracepoints and ftrace function tracepoints monitoring. CPU and system events happened when executing either in user or in kernel space can be monitored and captured for later analysis. Per-user per-cpu perf_event_mlock_kb locking limit is imposed but ignored for unprivileged processes with CAP_IPC_LOCK [^26] capability.

> ：*scope*包括每个进程和系统范围的性能监视，但不包括原始跟踪点和ftrace函数跟踪点监视。在用户空间或内核空间中执行时发生的CPU和系统事件可以被监控和捕获，以供稍后分析。对于具有CAP_IPC_LOCK[^26]功能的非特权进程，每个用户每个cpu的perf_event_mlock_kb锁定限制是强制的，但会被忽略。

\>=1:


:   *scope* includes per-process performance monitoring only and excludes system wide performance monitoring. CPU and system events happened when executing either in user or in kernel space can be monitored and captured for later analysis. Per-user per-cpu perf_event_mlock_kb locking limit is imposed but ignored for unprivileged processes with CAP_IPC_LOCK capability.

> ：*范围*仅包括每个进程的性能监控，不包括系统范围的性能监控。在用户空间或内核空间中执行时发生的CPU和系统事件可以被监控和捕获，以供稍后分析。对于具有CAP_IPC_LOCK功能的非特权进程，每个用户每个cpu的perf_event_mlock_kb锁定限制是强制的，但会被忽略。

\>=2:


:   *scope* includes per-process performance monitoring only. CPU and system events happened when executing in user space only can be monitored and captured for later analysis. Per-user per-cpu perf_event_mlock_kb locking limit is imposed but ignored for unprivileged processes with CAP_IPC_LOCK capability.

> ：*范围*仅包括每个流程的性能监控。只有在用户空间中执行时发生的CPU和系统事件才能被监控和捕获，以便稍后进行分析。对于具有CAP_IPC_LOCK功能的非特权进程，每个用户每个cpu的perf_event_mlock_kb锁定限制是强制的，但会被忽略。

# Resource control

## Open file descriptors


The perf_events system call API[^27] allocates file descriptors for every configured PMU event. Open file descriptors are a per-process accountable resource governed by the RLIMIT_NOFILE[^28] limit (ulimit -n), which is usually derived from the login shell process. When configuring Perf collection for a long list of events on a large server system, this limit can be easily hit preventing required monitoring configuration. RLIMIT_NOFILE limit can be increased on per-user basis modifying content of the limits.conf file[^29] . Ordinarily, a Perf sampling session (perf record) requires an amount of open perf_event file descriptors that is not less than the number of monitored events multiplied by the number of monitored CPUs.

> perf_events系统调用API[^27]为每个配置的PMU事件分配文件描述符。打开文件描述符是由RLIMIT_NOFILE[^28]限制（ulimit-n）管理的每个进程可负责的资源，该限制通常源自登录shell进程。在大型服务器系统上为一长串事件配置Perf集合时，很容易达到此限制，从而阻止所需的监视配置。RLIMIT_NOFILE限制可以根据每个用户修改limits.coff文件的内容[^29]来增加。通常，Perf采样会话（Perf记录）需要打开的Perf_event文件描述符的数量不小于被监视事件的数量乘以被监视CPU的数量。

## Memory allocation


The amount of memory available to user processes for capturing performance monitoring data is governed by the perf_event_mlock_kb[^30] setting. This perf_event specific resource setting defines overall per-cpu limits of memory allowed for mapping by the user processes to execute performance monitoring. The setting essentially extends the RLIMIT_MEMLOCK[^31] limit, but only for memory regions mapped specifically for capturing monitored performance events and related data.

> 用户进程可用于捕获性能监视数据的内存量由perf_event_mlock_kb[^30]设置决定。此perf_event特定的资源设置定义了允许用户进程映射以执行性能监视的每cpu内存的总体限制。该设置基本上扩展了RLIMIT_MEMLOCK[^31]限制，但仅适用于专门为捕获监视的性能事件和相关数据而映射的内存区域。


For example, if a machine has eight cores and perf_event_mlock_kb limit is set to 516 KiB, then a user process is provided with 516 KiB \* 8 = 4128 KiB of memory above the RLIMIT_MEMLOCK limit (ulimit -l) for perf_event mmap buffers. In particular, this means that, if the user wants to start two or more performance monitoring processes, the user is required to manually distribute the available 4128 KiB between the monitoring processes, for example, using the \--mmap-pages Perf record mode option. Otherwise, the first started performance monitoring process allocates all available 4128 KiB and the other processes will fail to proceed due to the lack of memory.

> 例如，如果一台机器有八个核，并且perf_event_mlock_kb限制设置为516 KiB，则为用户进程提供516 KiB\*8=4128 KiB的内存，高于perf_event mmap缓冲区的RLIMIT_MEMLOCK限制（ulimit-l）。特别是，这意味着，如果用户想要启动两个或多个性能监视进程，则需要用户在监视进程之间手动分配可用的4128 KiB，例如，使用\-mmap pages Perf记录模式选项。否则，第一个启动的性能监视进程将分配所有可用的4128KiB，而其他进程将由于内存不足而无法继续进行。


RLIMIT_MEMLOCK and perf_event_mlock_kb resource constraints are ignored for processes with the CAP_IPC_LOCK capability. Thus, perf_events/Perf privileged users can be provided with memory above the constraints for perf_events/Perf performance monitoring purpose by providing the Perf executable with CAP_IPC_LOCK capability.

> 对于具有CAP_IPC_LOCK功能的进程，将忽略RLIMIT_MEMBLOCK和perf_event_mlock_kb资源约束。因此，通过为perf可执行文件提供CAP_IPC_LOCK功能，可以为perf_events/perf特权用户提供高于性能监视目的约束的内存。

# Bibliography

[^1]: <https://lwn.net/Articles/337493/>

[^2]: <http://man7.org/linux/man-pages/man2/perf_event_open.2.html>

[^3]: <http://web.eece.maine.edu/~vweaver/projects/perf_events/>

[^4]: <http://man7.org/linux/man-pages/man2/perf_event_open.2.html>

[^5]: <http://web.eece.maine.edu/~vweaver/projects/perf_events/>

[^6]: <https://perf.wiki.kernel.org/index.php/Main_Page>

[^7]: <http://man7.org/linux/man-pages/man2/perf_event_open.2.html>

[^8]: <https://en.wikipedia.org/wiki/Hardware_performance_counter>

[^9]: <https://en.wikipedia.org/wiki/Model-specific_register>

[^10]: <https://www.kernel.org/doc/html/latest/security/credentials.html>

[^11]: <http://man7.org/linux/man-pages/man7/capabilities.7.html>

[^12]: <https://www.kernel.org/doc/html/latest/security/credentials.html>

[^13]: <http://man7.org/linux/man-pages/man7/capabilities.7.html>

[^14]: <https://sites.google.com/site/fullycapable>

[^15]: <http://man7.org/linux/man-pages/man8/auditd.8.html>

[^16]: <http://man7.org/linux/man-pages/man2/ptrace.2.html>

[^17]: <http://man7.org/linux/man-pages/man7/capabilities.7.html>

[^18]: <http://man7.org/linux/man-pages/man5/acl.5.html>

[^19]: <https://man7.org/linux/man-pages/man8/sudo.8.html>

[^20]: <http://man7.org/linux/man-pages/man7/capabilities.7.html>

[^21]: <https://git.kernel.org/pub/scm/libs/libcap/libcap.git/>

[^22]: <https://git.kernel.org/pub/scm/libs/libcap/libcap.git/>

[^23]: <http://man7.org/linux/man-pages/man7/capabilities.7.html>

[^24]: <http://man7.org/linux/man-pages/man2/perf_event_open.2.html>

[^25]: <http://man7.org/linux/man-pages/man2/perf_event_open.2.html>

[^26]: <http://man7.org/linux/man-pages/man7/capabilities.7.html>

[^27]: <http://man7.org/linux/man-pages/man2/perf_event_open.2.html>

[^28]: <http://man7.org/linux/man-pages/man2/getrlimit.2.html>

[^29]: <http://man7.org/linux/man-pages/man5/limits.conf.5.html>

[^30]: <http://man7.org/linux/man-pages/man2/perf_event_open.2.html>

[^31]: <http://man7.org/linux/man-pages/man2/getrlimit.2.html>
